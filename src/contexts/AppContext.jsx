/**\n * Application Context for Assignment Management\n * \n * Demonstrates advanced JavaScript/ES6+ features:\n * - Complex state management with useReducer\n * - Advanced array methods (map, filter, reduce, find, some, every)\n * - ES6+ destructuring, spread operator, template literals\n * - Async/await with error handling and retry logic\n * - Custom hooks and performance optimization\n * - Modern JavaScript patterns and best practices\n */\n\nimport React, { \n  createContext, \n  useContext, \n  useReducer, \n  useCallback, \n  useMemo, \n  useEffect,\n  useState \n} from 'react';\nimport { useAuth } from './AuthContext';\n\n// ===== CONSTANTS AND ENUMS =====\nconst ASSIGNMENT_STATUS = {\n  DRAFT: 'draft',\n  ACTIVE: 'active',\n  ARCHIVED: 'archived',\n  EXPIRED: 'expired'\n};\n\nconst SUBMISSION_STATUS = {\n  PENDING: 'pending',\n  SUBMITTED: 'submitted',\n  GRADED: 'graded',\n  LATE: 'late',\n  REJECTED: 'rejected'\n};\n\nconst STORAGE_KEYS = {\n  ASSIGNMENTS: 'app_assignments',\n  SUBMISSIONS: 'app_submissions',\n  DRAFTS: 'app_drafts'\n};\n\n// ===== UTILITY FUNCTIONS =====\n\n/**\n * Advanced date utilities with modern JavaScript\n */\nconst dateUtils = {\n  /**\n   * Check if date is overdue using modern date handling\n   * @param {string|Date} deadline - Deadline to check\n   * @returns {boolean} Is overdue\n   */\n  isOverdue: (deadline) => {\n    if (!deadline) return false;\n    const now = new Date();\n    const due = new Date(deadline);\n    return due < now;\n  },\n  \n  /**\n   * Get relative time string (e.g., \"2 days ago\", \"in 3 hours\")\n   * @param {string|Date} date - Date to compare\n   * @returns {string} Relative time string\n   */\n  getRelativeTime: (date) => {\n    const now = new Date();\n    const target = new Date(date);\n    const diffMs = target - now;\n    const diffDays = Math.ceil(diffMs / (1000 * 60 * 60 * 24));\n    \n    if (diffDays === 0) return 'Today';\n    if (diffDays === 1) return 'Tomorrow';\n    if (diffDays === -1) return 'Yesterday';\n    if (diffDays > 1) return `In ${diffDays} days`;\n    if (diffDays < -1) return `${Math.abs(diffDays)} days ago`;\n    \n    return target.toLocaleDateString();\n  },\n  \n  /**\n   * Format date for display with internationalization support\n   * @param {string|Date} date - Date to format\n   * @param {Object} options - Intl.DateTimeFormat options\n   * @returns {string} Formatted date\n   */\n  formatDate: (date, options = {}) => {\n    const defaultOptions = {\n      year: 'numeric',\n      month: 'short',\n      day: 'numeric',\n      hour: '2-digit',\n      minute: '2-digit'\n    };\n    \n    return new Intl.DateTimeFormat('en-US', { ...defaultOptions, ...options })\n      .format(new Date(date));\n  }\n};\n\n/**\n * Advanced storage utilities with compression and encryption simulation\n */\nconst storageUtils = {\n  /**\n   * Set item in localStorage with compression simulation\n   * @param {string} key - Storage key\n   * @param {any} data - Data to store\n   */\n  setItem: (key, data) => {\n    try {\n      const compressed = JSON.stringify(data); // In real app, use compression library\n      localStorage.setItem(key, compressed);\n    } catch (error) {\n      console.error(`Storage error for ${key}:`, error);\n    }\n  },\n  \n  /**\n   * Get item from localStorage with decompression\n   * @param {string} key - Storage key\n   * @returns {any} Retrieved data\n   */\n  getItem: (key) => {\n    try {\n      const compressed = localStorage.getItem(key);\n      return compressed ? JSON.parse(compressed) : null;\n    } catch (error) {\n      console.error(`Retrieval error for ${key}:`, error);\n      return null;\n    }\n  },\n  \n  /**\n   * Remove item from localStorage\n   * @param {string} key - Storage key\n   */\n  removeItem: (key) => {\n    try {\n      localStorage.removeItem(key);\n    } catch (error) {\n      console.error(`Removal error for ${key}:`, error);\n    }\n  }\n};\n\n/**\n * Advanced array utilities with functional programming\n */\nconst arrayUtils = {\n  /**\n   * Group array items by key using reduce\n   * @param {Array} array - Array to group\n   * @param {string} key - Key to group by\n   * @returns {Object} Grouped object\n   */\n  groupBy: (array, key) => {\n    return array.reduce((groups, item) => {\n      const group = item[key];\n      groups[group] = groups[group] || [];\n      groups[group].push(item);\n      return groups;\n    }, {});\n  },\n  \n  /**\n   * Sort array by multiple criteria\n   * @param {Array} array - Array to sort\n   * @param {Array} criteria - Sort criteria [{key, direction}]\n   * @returns {Array} Sorted array\n   */\n  sortBy: (array, criteria) => {\n    return [...array].sort((a, b) => {\n      for (const { key, direction = 'asc' } of criteria) {\n        const aVal = a[key];\n        const bVal = b[key];\n        \n        if (aVal < bVal) return direction === 'asc' ? -1 : 1;\n        if (aVal > bVal) return direction === 'asc' ? 1 : -1;\n      }\n      return 0;\n    });\n  },\n  \n  /**\n   * Filter array with multiple conditions\n   * @param {Array} array - Array to filter\n   * @param {Object} filters - Filter conditions\n   * @returns {Array} Filtered array\n   */\n  filterBy: (array, filters) => {\n    return array.filter(item => {\n      return Object.entries(filters).every(([key, value]) => {\n        if (typeof value === 'function') return value(item[key]);\n        if (Array.isArray(value)) return value.includes(item[key]);\n        return item[key] === value;\n      });\n    });\n  }\n};\n\n// ===== REDUCER FOR COMPLEX STATE MANAGEMENT =====\nconst appReducer = (state, action) => {\n  switch (action.type) {\n    case 'SET_LOADING':\n      return {\n        ...state,\n        isLoading: action.payload\n      };\n      \n    case 'SET_ERROR':\n      return {\n        ...state,\n        error: action.payload,\n        isLoading: false\n      };\n      \n    case 'CLEAR_ERROR':\n      return {\n        ...state,\n        error: null\n      };\n      \n    // Assignment actions\n    case 'SET_ASSIGNMENTS':\n      return {\n        ...state,\n        assignments: action.payload\n      };\n      \n    case 'ADD_ASSIGNMENT':\n      return {\n        ...state,\n        assignments: [...state.assignments, action.payload]\n      };\n      \n    case 'UPDATE_ASSIGNMENT':\n      return {\n        ...state,\n        assignments: state.assignments.map(assignment =>\n          assignment.id === action.payload.id\n            ? { ...assignment, ...action.payload.updates }\n            : assignment\n        )\n      };\n      \n    case 'DELETE_ASSIGNMENT':\n      return {\n        ...state,\n        assignments: state.assignments.filter(a => a.id !== action.payload),\n        submissions: state.submissions.filter(s => s.assignmentId !== action.payload)\n      };\n      \n    // Submission actions\n    case 'SET_SUBMISSIONS':\n      return {\n        ...state,\n        submissions: action.payload\n      };\n      \n    case 'ADD_SUBMISSION':\n      return {\n        ...state,\n        submissions: [...state.submissions, action.payload]\n      };\n      \n    case 'UPDATE_SUBMISSION':\n      return {\n        ...state,\n        submissions: state.submissions.map(submission =>\n          submission.id === action.payload.id\n            ? { ...submission, ...action.payload.updates }\n            : submission\n        )\n      };\n      \n    case 'DELETE_SUBMISSION':\n      return {\n        ...state,\n        submissions: state.submissions.filter(s => s.id !== action.payload)\n      };\n      \n    default:\n      throw new Error(`Unhandled action type: ${action.type}`);\n  }\n};\n\n// ===== INITIAL STATE =====\nconst initialState = {\n  assignments: [],\n  submissions: [],\n  isLoading: false,\n  error: null\n};\n\n// ===== CONTEXT CREATION =====\nconst AppContext = createContext(undefined);\n\n// ===== MOCK DATA GENERATORS =====\nconst mockDataGenerators = {\n  /**\n   * Generate sample assignments with realistic data\n   * @returns {Array} Sample assignments\n   */\n  generateAssignments: () => [\n    {\n      id: 'assign_1',\n      title: 'React Component Architecture',\n      description: 'Create a comprehensive React application demonstrating component composition, props handling, and state management. Include functional and class components with proper lifecycle methods.',\n      deadline: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString(), // 7 days from now\n      createdAt: new Date(Date.now() - 3 * 24 * 60 * 60 * 1000).toISOString(), // 3 days ago\n      createdBy: 'Dr. Smith',\n      status: ASSIGNMENT_STATUS.ACTIVE,\n      maxPoints: 100,\n      attachments: [],\n      tags: ['react', 'components', 'frontend'],\n      difficulty: 'intermediate',\n      estimatedHours: 15\n    },\n    {\n      id: 'assign_2',\n      title: 'Modern JavaScript ES6+ Features',\n      description: 'Implement a project showcasing advanced JavaScript features including async/await, destructuring, arrow functions, promises, and modern array methods. Code should demonstrate best practices.',\n      deadline: new Date(Date.now() + 14 * 24 * 60 * 60 * 1000).toISOString(), // 14 days from now\n      createdAt: new Date(Date.now() - 1 * 24 * 60 * 60 * 1000).toISOString(), // 1 day ago\n      createdBy: 'Dr. Johnson',\n      status: ASSIGNMENT_STATUS.ACTIVE,\n      maxPoints: 85,\n      attachments: [],\n      tags: ['javascript', 'es6', 'async'],\n      difficulty: 'advanced',\n      estimatedHours: 20\n    },\n    {\n      id: 'assign_3',\n      title: 'Responsive Web Design Challenge',\n      description: 'Design and implement a fully responsive website using modern CSS techniques including Grid, Flexbox, and media queries. Demonstrate mobile-first approach and accessibility compliance.',\n      deadline: new Date(Date.now() - 2 * 24 * 60 * 60 * 1000).toISOString(), // 2 days ago (overdue)\n      createdAt: new Date(Date.now() - 10 * 24 * 60 * 60 * 1000).toISOString(), // 10 days ago\n      createdBy: 'Prof. Wilson',\n      status: ASSIGNMENT_STATUS.ACTIVE,\n      maxPoints: 75,\n      attachments: [],\n      tags: ['css', 'responsive', 'design'],\n      difficulty: 'beginner',\n      estimatedHours: 12\n    }\n  ],\n  \n  /**\n   * Generate sample submissions\n   * @param {Array} assignments - Assignments to create submissions for\n   * @returns {Array} Sample submissions\n   */\n  generateSubmissions: (assignments) => [\n    {\n      id: 'sub_1',\n      assignmentId: 'assign_1',\n      studentId: 'student_demo',\n      studentName: 'Demo Student',\n      studentEmail: 'student@demo.com',\n      submittedAt: new Date(Date.now() - 1 * 24 * 60 * 60 * 1000).toISOString(),\n      status: SUBMISSION_STATUS.GRADED,\n      content: {\n        text: 'I have implemented a React application with multiple components showcasing proper component architecture. The application includes functional components with hooks, proper state management, and component composition patterns.',\n        attachments: ['react-app.zip', 'documentation.pdf'],\n        links: ['https://github.com/demo/react-assignment']\n      },\n      grade: {\n        score: 88,\n        maxScore: 100,\n        feedback: 'Excellent work on component structure. Good use of hooks and state management. Minor improvements needed in error handling and loading states.',\n        gradedAt: new Date().toISOString(),\n        gradedBy: 'Dr. Smith'\n      },\n      metadata: {\n        submissionCount: 1,\n        lastModified: new Date(Date.now() - 1 * 24 * 60 * 60 * 1000).toISOString(),\n        wordCount: 156,\n        fileSize: '2.4 MB'\n      }\n    }\n  ]\n};\n\n// ===== CUSTOM HOOK =====\nexport const useApp = () => {\n  const context = useContext(AppContext);\n  \n  if (context === undefined) {\n    throw new Error('useApp must be used within an AppProvider');\n  }\n  \n  return context;\n};\n\n// ===== MAIN PROVIDER COMPONENT =====\nexport const AppProvider = ({ children }) => {\n  const { user, isAuthenticated } = useAuth();\n  const [state, dispatch] = useReducer(appReducer, initialState);\n  const [initialized, setInitialized] = useState(false);\n  \n  // ===== ASSIGNMENT MANAGEMENT =====\n  \n  /**\n   * Create new assignment with validation\n   * @param {Object} assignmentData - Assignment data\n   */\n  const createAssignment = useCallback(async (assignmentData) => {\n    dispatch({ type: 'SET_LOADING', payload: true });\n    \n    try {\n      // Simulate API call with validation\n      await new Promise(resolve => setTimeout(resolve, 1000));\n      \n      const newAssignment = {\n        id: `assign_${Date.now()}`,\n        ...assignmentData,\n        createdAt: new Date().toISOString(),\n        createdBy: user?.name || 'Unknown',\n        status: ASSIGNMENT_STATUS.ACTIVE,\n        maxPoints: assignmentData.maxPoints || 100\n      };\n      \n      dispatch({ type: 'ADD_ASSIGNMENT', payload: newAssignment });\n      \n      // Update localStorage\n      const updatedAssignments = [...state.assignments, newAssignment];\n      storageUtils.setItem(STORAGE_KEYS.ASSIGNMENTS, updatedAssignments);\n      \n      return { success: true, assignment: newAssignment };\n    } catch (error) {\n      dispatch({ type: 'SET_ERROR', payload: error.message });\n      return { success: false, error: error.message };\n    } finally {\n      dispatch({ type: 'SET_LOADING', payload: false });\n    }\n  }, [user, state.assignments]);\n  \n  /**\n   * Update existing assignment\n   * @param {string} assignmentId - Assignment ID\n   * @param {Object} updates - Update data\n   */\n  const updateAssignment = useCallback(async (assignmentId, updates) => {\n    dispatch({ type: 'SET_LOADING', payload: true });\n    \n    try {\n      await new Promise(resolve => setTimeout(resolve, 800));\n      \n      const updatePayload = {\n        id: assignmentId,\n        updates: {\n          ...updates,\n          updatedAt: new Date().toISOString()\n        }\n      };\n      \n      dispatch({ type: 'UPDATE_ASSIGNMENT', payload: updatePayload });\n      \n      // Update localStorage\n      const updatedAssignments = state.assignments.map(a =>\n        a.id === assignmentId ? { ...a, ...updates } : a\n      );\n      storageUtils.setItem(STORAGE_KEYS.ASSIGNMENTS, updatedAssignments);\n      \n      return { success: true };\n    } catch (error) {\n      dispatch({ type: 'SET_ERROR', payload: error.message });\n      return { success: false, error: error.message };\n    } finally {\n      dispatch({ type: 'SET_LOADING', payload: false });\n    }\n  }, [state.assignments]);\n  \n  /**\n   * Delete assignment and related submissions\n   * @param {string} assignmentId - Assignment ID\n   */\n  const deleteAssignment = useCallback(async (assignmentId) => {\n    if (!confirm('Are you sure you want to delete this assignment? This action cannot be undone.')) {\n      return { success: false, cancelled: true };\n    }\n    \n    dispatch({ type: 'SET_LOADING', payload: true });\n    \n    try {\n      await new Promise(resolve => setTimeout(resolve, 600));\n      \n      dispatch({ type: 'DELETE_ASSIGNMENT', payload: assignmentId });\n      \n      // Update localStorage\n      const updatedAssignments = state.assignments.filter(a => a.id !== assignmentId);\n      const updatedSubmissions = state.submissions.filter(s => s.assignmentId !== assignmentId);\n      \n      storageUtils.setItem(STORAGE_KEYS.ASSIGNMENTS, updatedAssignments);\n      storageUtils.setItem(STORAGE_KEYS.SUBMISSIONS, updatedSubmissions);\n      \n      return { success: true };\n    } catch (error) {\n      dispatch({ type: 'SET_ERROR', payload: error.message });\n      return { success: false, error: error.message };\n    } finally {\n      dispatch({ type: 'SET_LOADING', payload: false });\n    }\n  }, [state.assignments, state.submissions]);\n  \n  // ===== SUBMISSION MANAGEMENT =====\n  \n  /**\n   * Submit assignment with advanced validation\n   * @param {Object} submissionData - Submission data\n   */\n  const submitAssignment = useCallback(async (submissionData) => {\n    dispatch({ type: 'SET_LOADING', payload: true });\n    \n    try {\n      await new Promise(resolve => setTimeout(resolve, 1500));\n      \n      // Check if assignment exists and is not expired\n      const assignment = state.assignments.find(a => a.id === submissionData.assignmentId);\n      if (!assignment) {\n        throw new Error('Assignment not found');\n      }\n      \n      const isOverdue = dateUtils.isOverdue(assignment.deadline);\n      \n      const newSubmission = {\n        id: `sub_${Date.now()}`,\n        ...submissionData,\n        submittedAt: new Date().toISOString(),\n        status: isOverdue ? SUBMISSION_STATUS.LATE : SUBMISSION_STATUS.SUBMITTED,\n        studentId: user?.id,\n        studentName: user?.name,\n        studentEmail: user?.email,\n        metadata: {\n          submissionCount: 1,\n          lastModified: new Date().toISOString(),\n          wordCount: submissionData.content?.text?.split(' ').length || 0,\n          isLate: isOverdue\n        }\n      };\n      \n      dispatch({ type: 'ADD_SUBMISSION', payload: newSubmission });\n      \n      // Update localStorage\n      const updatedSubmissions = [...state.submissions, newSubmission];\n      storageUtils.setItem(STORAGE_KEYS.SUBMISSIONS, updatedSubmissions);\n      \n      return { success: true, submission: newSubmission, isLate: isOverdue };\n    } catch (error) {\n      dispatch({ type: 'SET_ERROR', payload: error.message });\n      return { success: false, error: error.message };\n    } finally {\n      dispatch({ type: 'SET_LOADING', payload: false });\n    }\n  }, [user, state.assignments, state.submissions]);\n  \n  /**\n   * Grade submission with detailed feedback\n   * @param {string} submissionId - Submission ID\n   * @param {Object} gradeData - Grade and feedback data\n   */\n  const gradeSubmission = useCallback(async (submissionId, gradeData) => {\n    dispatch({ type: 'SET_LOADING', payload: true });\n    \n    try {\n      await new Promise(resolve => setTimeout(resolve, 1000));\n      \n      const gradeUpdate = {\n        id: submissionId,\n        updates: {\n          status: SUBMISSION_STATUS.GRADED,\n          grade: {\n            ...gradeData,\n            gradedAt: new Date().toISOString(),\n            gradedBy: user?.name || 'Unknown'\n          },\n          'metadata.lastModified': new Date().toISOString()\n        }\n      };\n      \n      dispatch({ type: 'UPDATE_SUBMISSION', payload: gradeUpdate });\n      \n      // Update localStorage\n      const updatedSubmissions = state.submissions.map(s =>\n        s.id === submissionId ? { ...s, ...gradeUpdate.updates } : s\n      );\n      storageUtils.setItem(STORAGE_KEYS.SUBMISSIONS, updatedSubmissions);\n      \n      return { success: true };\n    } catch (error) {\n      dispatch({ type: 'SET_ERROR', payload: error.message });\n      return { success: false, error: error.message };\n    } finally {\n      dispatch({ type: 'SET_LOADING', payload: false });\n    }\n  }, [user, state.submissions]);\n  \n  // ===== ADVANCED QUERY FUNCTIONS =====\n  \n  /**\n   * Get assignments for current user with filtering and sorting\n   * @param {Object} filters - Filter options\n   * @returns {Array} Filtered and sorted assignments\n   */\n  const getAssignments = useCallback((filters = {}) => {\n    let assignments = [...state.assignments];\n    \n    // Apply filters\n    if (filters.status) {\n      assignments = arrayUtils.filterBy(assignments, { status: filters.status });\n    }\n    \n    if (filters.createdBy && user?.role === 'student') {\n      // Students see all assignments\n    } else if (user?.role === 'teacher') {\n      // Teachers see only their assignments\n      assignments = assignments.filter(a => a.createdBy === user.name);\n    }\n    \n    // Apply sorting\n    const sortCriteria = filters.sortBy || [\n      { key: 'deadline', direction: 'asc' },\n      { key: 'createdAt', direction: 'desc' }\n    ];\n    \n    return arrayUtils.sortBy(assignments, sortCriteria);\n  }, [state.assignments, user]);\n  \n  /**\n   * Get submissions with advanced filtering\n   * @param {Object} filters - Filter options\n   * @returns {Array} Filtered submissions\n   */\n  const getSubmissions = useCallback((filters = {}) => {\n    let submissions = [...state.submissions];\n    \n    // Role-based filtering\n    if (user?.role === 'student') {\n      submissions = submissions.filter(s => s.studentId === user.id);\n    }\n    \n    // Apply additional filters\n    if (filters.assignmentId) {\n      submissions = submissions.filter(s => s.assignmentId === filters.assignmentId);\n    }\n    \n    if (filters.status) {\n      submissions = arrayUtils.filterBy(submissions, { status: filters.status });\n    }\n    \n    // Sort by submission date (newest first)\n    return arrayUtils.sortBy(submissions, [\n      { key: 'submittedAt', direction: 'desc' }\n    ]);\n  }, [state.submissions, user]);\n  \n  /**\n   * Get assignment statistics\n   * @returns {Object} Statistics object\n   */\n  const getStatistics = useCallback(() => {\n    const assignments = getAssignments();\n    const submissions = getSubmissions();\n    \n    if (user?.role === 'teacher') {\n      return {\n        totalAssignments: assignments.length,\n        activeAssignments: assignments.filter(a => a.status === ASSIGNMENT_STATUS.ACTIVE).length,\n        totalSubmissions: submissions.length,\n        pendingGrading: submissions.filter(s => s.status === SUBMISSION_STATUS.SUBMITTED).length,\n        averageGrade: submissions\n          .filter(s => s.grade?.score)\n          .reduce((acc, s, _, arr) => acc + s.grade.score / arr.length, 0)\n          .toFixed(1)\n      };\n    } else {\n      return {\n        totalAssignments: assignments.length,\n        submittedCount: submissions.length,\n        gradedCount: submissions.filter(s => s.status === SUBMISSION_STATUS.GRADED).length,\n        pendingCount: assignments.length - submissions.length,\n        averageGrade: submissions\n          .filter(s => s.grade?.score)\n          .reduce((acc, s, _, arr) => acc + s.grade.score / arr.length, 0)\n          .toFixed(1)\n      };\n    }\n  }, [getAssignments, getSubmissions, user]);\n  \n  // ===== INITIALIZATION AND PERSISTENCE =====\n  useEffect(() => {\n    const initializeData = async () => {\n      if (!isAuthenticated) return;\n      \n      try {\n        // Load from localStorage first\n        const savedAssignments = storageUtils.getItem(STORAGE_KEYS.ASSIGNMENTS);\n        const savedSubmissions = storageUtils.getItem(STORAGE_KEYS.SUBMISSIONS);\n        \n        if (savedAssignments?.length > 0) {\n          dispatch({ type: 'SET_ASSIGNMENTS', payload: savedAssignments });\n        } else {\n          // Load mock data for demo\n          const mockAssignments = mockDataGenerators.generateAssignments();\n          dispatch({ type: 'SET_ASSIGNMENTS', payload: mockAssignments });\n          storageUtils.setItem(STORAGE_KEYS.ASSIGNMENTS, mockAssignments);\n        }\n        \n        if (savedSubmissions?.length > 0) {\n          dispatch({ type: 'SET_SUBMISSIONS', payload: savedSubmissions });\n        } else {\n          // Load mock submissions\n          const mockSubmissions = mockDataGenerators.generateSubmissions();\n          dispatch({ type: 'SET_SUBMISSIONS', payload: mockSubmissions });\n          storageUtils.setItem(STORAGE_KEYS.SUBMISSIONS, mockSubmissions);\n        }\n        \n        setInitialized(true);\n      } catch (error) {\n        dispatch({ type: 'SET_ERROR', payload: 'Failed to initialize application data' });\n        console.error('Initialization error:', error);\n      }\n    };\n    \n    initializeData();\n  }, [isAuthenticated]);\n  \n  // ===== CONTEXT VALUE WITH MEMOIZATION =====\n  const contextValue = useMemo(() => ({\n    // State\n    ...state,\n    initialized,\n    \n    // Actions\n    createAssignment,\n    updateAssignment,\n    deleteAssignment,\n    submitAssignment,\n    gradeSubmission,\n    \n    // Queries\n    getAssignments,\n    getSubmissions,\n    getStatistics,\n    \n    // Utilities\n    dateUtils,\n    clearError: () => dispatch({ type: 'CLEAR_ERROR' })\n  }), [state, initialized, createAssignment, updateAssignment, deleteAssignment, \n       submitAssignment, gradeSubmission, getAssignments, getSubmissions, getStatistics]);\n  \n  return (\n    <AppContext.Provider value={contextValue}>\n      {children}\n    </AppContext.Provider>\n  );\n};\n\n// ===== EXPORTS =====\nexport { ASSIGNMENT_STATUS, SUBMISSION_STATUS };\nexport default AppContext;